# JPA 소개 

<br>

# 1. SQL 중심적인 개발의 문제점

- 지금 시대는 객체를 관계형 DB에 관리하는 시대
- 객체 CRUD(CREATE, READ, UPDATE, DELETE) 무한 반복
- 객체 와 관계형 DB의 패러다임 불일치
	- 상속: 관계형 DB에는 상속이라는 개념이 없어서 관련된 TABLE에 모두 쿼리를 날리거나 JOIN을 통해 조회해야함.)
	- 연관관계: 객체는 참조를 사용, 테이블은 외래 키를 사용
	- 데이터 타입
	- 데이터 식별 방법
- 객체 그래프 탐색: 객체는 자유롭게 객체 그래프를 탐색할 수 있어야 함
- SQL은 JOIN에 따라 탐색 범위가 결정
- 엔티티 신뢰 문제: 온전히 객체가 모든 기능을 다 수행해야 신뢰할 수 있는데 SQL문에 따라서 member.getTeam()에 값이 들어갈 수도 , null이 될 수도 있어서 엔티티를 신뢰할 수 없게 된다.
- 객체답게 모델링 할수록 SQL문으로 매핑 작업만 늘어남

<br>

# 2. JPA(Java Persistence API)
- 자바 진영의 ORM 기술 표준
	- Object-relational mapping
	- 관계형 데이터베이스는 관계형 데이터베이스대로 설계
	- ORM 프레임워크가 중간에서 매핑 작업
- 자바 애플리케이션과 JDBC 사이에서 동작
- JPA는 표준 명세
	- JPA는 인터페이스의 모음
	- JPA 표준 명세를 구현한 3가지 구현체
	- 하이버네이트, 이클립스링크, DataNucleus

<br>

## JPA를 사용해야 하는 이유
- SQL 중심적 개발에서 객체 중심으로 개발 가능
- 생산성(코드가 매우 간결해짐)
- 유지보수(객체 중심으로 개발하면서 자바 본연의 특징을 살려 유지 보수가 쉬움)
- 패러다임의 불일치 해결(JDBC와 중간에서 매핑역할)
- 성능
- 데이터 접근 추상화
- DB에 객체를 저장하는 것을 자바의 컬렉션에 저장하는 것처럼 사용할 수 있음.

<br>

## JPA 성능 최적화 기능
- 1차 캐시와 동일성 보장: 같은 트랜잭션 안에서는 같은 엔티티 반환
- 트랜잭션을 지원하는 쓰기 지연: 트랜잭션을 커밋할 때까지 INSERT SQL문 모아둠
- 지연로딩 및 즉시로딩 지원
	- 지연로딩: 객체가 실제 사용될 때 로딩
	- 즉시로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회




