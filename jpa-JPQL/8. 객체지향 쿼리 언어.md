# 객체지향 쿼리 언어1

<br>

## 목차
- 객체지향 쿼리 언어 소개
- JPQL
- 기본 문법과 기능
- 페치 조인
- 경로 표현식
- 다현성 쿼리
- 엔티티 직접 사용
- Named 쿼리
- 벌크 연산

<br>

# 1. 객체지향 쿼리 언어 소개

## JPA 가 지원하는 쿼리 방법
- JPQL
- JPA Criteria
- QueryDSL
- 네이티브 SQL
- JDBC API 직접 사용, MyBatis, SpringJdbTemplate 함께 사용

<br>

## JPQL
```java
//검색
 String jpql = "select m From Member m where m.name like ‘%hello%'"; 
 List<Member> result = em.createQuery(jpql, Member.class)
 .getResultList();
```

- 테이블이 아닌 객체를 대상으로 하는 객체 지향 쿼리
- SQL과 문법 유사
- 모든 DB데이터를 객체로 변환하여 검색하는 것은 불가능
- 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요
- SQL을 추상화하여 특정 데이터베이스에 SQL에 의존x
- 동적 쿼리 작성이 힘듦

<br>

## Criteria
```java
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder(); 
CriteriaQuery<Member> query = cb.createQuery(Member.class); 

//루트 클래스 (조회를 시작할 클래스)
Root<Member> m = query.from(Member.class); 

//쿼리 생성 CriteriaQuery<Member> cq = 
query.select(m).where(cb.equal(m.get("username"), “kim”)); 
List<Member> resultList = em.createQuery(cq).getResultList();
```
- 문자가 아닌 자바 코드로 JPQL을 작성
- JPQL 빌더 역할
- JPA의 공식 기능
- 너무 복잡하고 실용성이 없음(유지보수가 힘듦)
- 코드가 직관적이지 않음

<br>

## QureryDSL
```java
//JPQL 
 //select m from Member m where m.age > 18
 JPAFactoryQuery query = new JPAQueryFactory(em);
 QMember m = QMember.member; 

 List<Member> list = 
    query.selectFrom(m)
        .where(m.age.gt(18)) 
        .orderBy(m.name.desc())
        .fetch();
 ```
- 문자가 아닌 자바 코드로 JPQL 작성
- JPQL 빌더 역할
- 컴파일 시점에 문법 오류를 찾을 수 있음
- 동적 쿼리 작성 편리함
- 실무에서 자주 사용함
- 코드가 직관적임

<br>

## 네이티브 SQL 
```java
String sql = 
 "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = ‘kim’"; 

List<Member> resultList = 
    em.createNativeQuery(sql, Member.class).getResultList();
```
- JPA가 제공하는 SQL을 직접 사용하는 기능
- JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능
- 예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트

<br>

## JDBC 직접 사용, SpringJdbcTemplate 
- JPA를 사용하면서 JDBV 커넥션을 직접 사용하거나, 스프링 JdbcTeplat, 마이바티스등을 함께 사용 가능
- 단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요
- 예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트를 수동으로 플러시

<br>

# 2. JPQL - 기본 문법과 기능
- JPQL은 객체지향 쿼리 언어
- 엔티티 객체를 대상으로 쿼리
- SQL을 추상화 하기 때문에 특정 데이터베이스 SQL에 의존하지 않음
- JPQL은 결국 SQL로 변환됨

## JPQL 문법
```
select_문 :: = 
 select_절
 from_절
 [where_절] 
 [groupby_절] 
 [having_절] 
 [orderby_절] 

update_문 :: = update_절 [where_절] 
delete_문 :: = delete_절 [where_절]
```

- select m from Member as m where m.age > 18 
- 엔티티와 속성은 대소문자 구분O (Member, age) 
- JPQL 키워드는 대소문자 구분X (SELECT, FROM, where) 
- 엔티티 이름 사용, 테이블 이름이 아님(Member) 
- 별칭은 필수(m) (as는 생략가능)

## 집합과 정렬
```
select
 COUNT(m), //회원수
 SUM(m.age), //나이 합
 AVG(m.age), //평균 나이
 MAX(m.age), //최대 나이
 MIN(m.age) //최소 나이
from Member m
``` 
<Br>

## TypeQuery, Query
- TypeQuery: 반환 타입이 명확할 때 사용
- Query: 반환 타입이 명확하지 않을 때 사용
```java
TypedQuery<Member> query = 
 em.createQuery("SELECT m FROM Member m", Member.class); 
```
```java
Query query = 
 em.createQuery("SELECT m.username, m.age from Member m");
```

<br>

## 결과 조회 API
- query.getResultList(): 결과가 하나 이상일때, 리스트 반환
    - 결과가 없으면 빈 리스트 반환
- query.getSingleResult(): 결과가 정확히 하나, 단일 객체 반환
    - 결과가 없으면 NoResultException
    - 둘 이상이면 NonUniqueResultException

<br>

## 파라미터 바인딩 - 이름, 위치 기준
- 이름기준
```java
SELECT m FROM Member m where m.username=:username 
query.setParameter("username", usernameParam);
```
- 위치기준
```java
SELECT m FROM Member m where m.username=?1 
query.setParameter(1, usernameParam);

```
- 이름기준을 사용하자.
- 위치 기준으로 하면 순서 혼동 및 위치 변동이 어려움.

<br>

# 3. 프로젝션
- SELECT절에 조회할 대상을 지정하는 것
- 프로젝션 대상: 엔티티, 임베디드타입, 스칼라 타입(기본 데이터 타입)
- SELECT m FROM Member m -> 엔티티 프로젝션
- SELECT m.team FROM Member m -> 엔티티 프로젝션
- SELECT m.address FROM Member m -> 임베디드 타입 프로젝션
- SELECT m.username, m.age FROM Member m -> 스칼라 타입 프로젝션
- DISTINCT로 중복 제거

<br>

## 프로젝션 - 여러 값 조회
- SELECT m.username, m.age FROM Member m 
- 1. Query 타입으로 조회
```java
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush();
            em.clear();

            Query query = em.createQuery("select m.username, m.age from Member m");

            List resultList = query.getResultList();
            Object o = resultList.get(0);
            Object[] result = (Object[]) o;

            System.out.println("m.username = " + result[0]);
            System.out.println("m.age = " + result[1]);
```
- 2. Object[] 타입으로 조회
```java
Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush();
            em.clear();

            List<Object[]> resultList = em.createQuery("select m.username, m.age from Member m")
                    .getResultList();

            Object[] result = resultList.get(0);
            
            System.out.println("m.username = " + result[0]);
            System.out.println("m.age = " + result[1]);
```
- 3. new 명령어로 조회
```java
Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush();
            em.clear();

            List<MemberDTO> memberDTOS = em.createQuery("select new jpql.MemberDTO(m.username, m.age) from Member m", MemberDTO.class)
                    .getResultList();

            MemberDTO memberDTO = memberDTOS.get(0);

            System.out.println("m.username = " + memberDTO.getUsername());
            System.out.println("m.age = " + memberDTO.getAge());
```
- 단순 값을 DTO로 바로 조회 SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m 
- 패키지 명을 포함한 전체 클래스 명 입력
- 순서와 타입이 일치하는 생성자 필요

```java
public MemberDTO(String username, int age) {
    this.username = username;
    this.age = age;
}
```

















